SQL 최적화 기본 원리
---
1. 옵티마이저
 옵티마이저는 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할을 수행한다. 이러한 최적의 실행 방법을 실행계획 이라고 한다. 이러한 옵티마이저는 최적의 실행 방법을 결정하는 방식에 따라 규칙기반 옵티마이저(RBO, Rule Based Optimizer)와 비용 기반 옵티마이저(CBO, Cost Based Optimizer)로 구분할 수 있다.
  - 규칙기반의 옵티마이저
    - 규칙(우선순위)을 가지고 실행계획을 생성한다. 실행게획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측 할 수 있다. SQL문을 싱행하기 위해 인덱스 유무와 종류, SQL문 에서 사용하는 연산자의 종류 그리고 SQL 문에서 참조하는 객체의 종류가 있다. 이러한 정보에 따라 우선 순위가 정해져 있고, 이 우선순위를 기반으로 실행 계획을 생성한다.
  - 비용기반의 옵티마이저
    - 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계왹을 선택하는 방식이다. 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다. 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보와 시스템 통계정보 등을 이용한다.

2. 인덱스 테이블
  인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념이다. 인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다. 테이블에 인덱스를 생성하지 않아도 되고 여러개를 생성해도 된다. 인덱스의 기본적인 목적은 검색 성능의 최적화이다. 즉, 검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다. 하지만, Insert, Update, Delete 등과 같은 DML 작업은 테이블과 인덱스를 함께 변경해야 하기 때문에 오히려 느려질 수 있다는 단점이 있다.
    - 전체 테이블 스캔
      1. SQL문에 조건지 존재하지 않는 경우
      2. SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우
      3. 옵티마이저의 취사 선택
      4. 그 밖의 경우
        - 병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.
    - 인덱스 테이블 스캔
      1. 인덱스 유일 스캔
      2. 인덱스 범위 스캔
      3. 인덱스 역순 범위 스캔

3. 인덱스 스캔 방식
  - Index Range Scan
    - Index Range Scan은 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위(Range)만 스캔하는 방식이다. B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있다.
  - Index Full Scan
    - Index Full Scan은 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐생하는 방식으로서. 대개는 데이터 검색을 위한 최적의 인덱스가 없을때 차선으로 선택된다.
      * Index Full Scan의 효용성
        - 선두 칼럼이 조건절에 없으면 옵티마이저는 우선적으로 Table Full Scan을 고려한다. 그런데 대용량 테이블이어서 Table Full Scan의 부탐이 크다면 옵티마엊는 인덱스를 활요하는 방법을 다시 생각해 보지 않을 수 없다. 데이터 저장공간은 '가로*세로' 즉, '칼럼길이*레코드 수'에 의해 결정되므로 대개 인덱스가 차지하는 면적은 테이블보다 훨씬 적게 마련이다. 만약 인덱스 스캔 단계에서 대부분 레코드를 필터링 하고 일부에 대해서만 테이블 액세스가 발생하는 경우라면 테이블 전체를 스캔하는 것 보다 탓다. 이럴때 옵티마이저는 Index Full Scan 방식을 선택 할 수 있다.
      * 인덱스를 이용한 소트 연산 대체
        - Index Full Scan은 Index Range Scan과 마찬가지로 그 결과집합이 인덱스 칼럼 순으로 정렬 되므로 Sort Order By 연산을 생략할 목적으로 사용 될 수 있는데, 이는 차선책으로 선택됐다기보다 옵티마이저가 전략적으로 선택한 경우에 해당한다.
  - Index Unique Scan
    - Index Unique Scan은 수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.
  - Index Skip Scan
    - 인덱스 선두 칼럼이 조건절로 사용되지 않으면 옵티아미저는 기본적으로 Table Full Scan을 선택한다. 또는, Table Full Scan 보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan 방식을 사용한다고 했다. Oracle은 인덱스 선두 칼럼이 조건절에 빠졌어도 인덱스를 활용하는 새로운 스캔방식을 9i 버전부터 선보였는데, 바로 index Skip Scan이 그것이다.

    Index Skip Scan 내부 수행 원리를 간단히 요약하면, 루트 또는 브랜치 블록에서 읽은 칼럼값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성 있는 하위 블록만 골라서 액세스 하는 방식이라고 할 수 있다.

  - Index Fast Full Scan
    - 말 그대로 Index Fast Full Scan은 Index Full Scan보다 빠르다. Index Fast Full Scan이 Index Full Scan보다 빠른 이유는, 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Mulitiblock Read 방식으로 스캔하기 때문이다.

|Index Full Scan|Index Fast Full Scan|
|:-----------|:-------------------|
|1. 인덱스 구조를 따라 스캔|1. 세그먼트 전체를 스캔|
|2. 결과집합 순서 보장|2. 결과집합 순서 보장 안됨|
|3. Single Block I/O|2. MultiBlock I.O|
|4. 병렬스캔 불가(파티션 돼 있지 않다면)   |4. 병렬스캔 가능   |
|5. 인덱스에 포함되지 않은 칼럼 조회 시에도 사용 가능   |5. 인덱스에 포함된 칼럼으로만 조회 할 때 사용 가능   |

  - Index Range Scan Descending
    - Index Range Scan과 기본적으로 동일한 스캔 방식이다. 다만, 인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과 집학을 얻는다는 점만 다르다.

5. 인덱스 종류
  - B*Tree 인덱스
    - 모든 DBMS가 B*Tree 인덱스를 기본적으로 제공하며, 추가적으로 제공하는 인덱스 구조는 모두 B*Tree 인덱스의 단첨을 보완하기 위해 개발된 것들이다.
      1. Unbalanced Index
        - Delete 작업 대문에 인덱스가 불균형(Unbalanced) 상태에 놓일 수 있다. 즉, 다른 리프 노드에 비해 루트 블록과의 거리가 더 멀거나 가까운 리프 노드가 생길 수 있다는 것인데, B*Tree 구조에서 이런 현상은 절대 발생하지 않는다.
        BTree인덱스의 'B'는 'Balanced'의 약자로서, 인덱스 루트에서 리프 블록까지 어떤 값으로 탐색 하더라도 읽는 블록수가 같음을 의미한다. 즉, 루트로브터 모든 리프 블록까지의 높이가 동일하다.
      2. Index Skew
        - 불균형(Unbalanced)은 생길 수 없지만 Index Fragmentation에 의한 Index Skew 또는 Sparse 현상이 생기는 경우는 종종 있고, 이는 인덱스 스캔 효율에 나쁜 영향을 미칠 수 있다. Index Skew는 인덱스 엔트리가 왼쪽 또는 오른쪽에 치우치는 현상을 말한다. 예를 들러, 아래와 같이 대량의 Delete 작업을 마치고 나면 인덱스 왼쪽에 있는 리프 블럭들은 텅비는 반면 반대편은 꽉 찬 상태가 된다.
        Oracle의 경우, 텅 빈 인덱스 블록은 커밋하는 순간 freelist로 반환되지만 인덱스 구조상에는 그대로 남는다. 상위 브랜치에서 해당 리프블록을 가리키는 엔트리가 그대로 남아 있어 인덱스 정렬 순서상 그곳에 입력될 새로운 값이 들어오면 언제든 재 사용 될 수 있다. 새로운 값이 하나라도 입력되기 전 다른 노드에 인덱스 엔트리가 사용된다. 이때는 상위 브랜치에 해당 리프 블록을 가르키는 엔트리가 제거돼 다른쪽 브랜치의 자식 노드로 이동하고, freelist에서도 제거된다. 레코드가 모두 삭제된 블록은 이처럼 언제든 재 사용 가능하지만, 문제는 다시 채워질 때 까지 인덱스 스캔 효율이 낮아는 데에 있다. SQL Server에선 index Shew 현상이 발생하지 않는다. 주기적으로 BTree 인덱스를 체크함으로써 지ㅜ어진 레코드와 페이지를 정리해 주는 메커니즘을 갖기 때문이다. 인덱스 레코드를 지우면 리프코드로 마크되어있다가 이를 정리해주는 별도 쓰레드에 의해 비동기 방식으로 제거되는데, 그 과정에서 텅 빈 페이지가 발견되면 인덱스 구조에서 제거된다.
      3. index Sparse
        - 인덱스 블록 전반에 걸쳐 밀도(Density)가 떨어지는 현상을 말한다. 지워진 자리에 인덱스 정렬 순서에 따라 새로운 값이 입력되면 그 공간은 재사용되지만 위와 같은 대량의 delete 작업이 있고 난 후 한동안 인덱스 스캔 효율이 낮다는 데에 문제가 있다. 왼쪽, 오른쪽, 중간 어디든 Index Skew처럼 블록이 아예 텅 비면 곧바로 freelist로 반환돼 언제든 재사용되지만, Index Sparse는 지워진 자리에 새로운 값이 입력되지 않으면 영영 재사용되지 않을 수도 있다. 총 레코드 건수가 일정한데도 인덱스 공간 사용량이 계속 커지는 것은 대개 이런 현상에 기인한다.
      4. 인덱스 재생성
        - Fragmentation 때문에 인덱스 크기가 계속 증가하고 스캔 효율이 나빠지면 인덱스를 재생성하거나 DBMS가 제공하는 명령어를 이용해 빈 공간을 제거하는 것이 유용할 수 있다. 하지만 일반적으로 인덱스 블록에서 어느 정도 공간을 남겨두는 것이 좋다. 왜냐하면, 빈 공간을 제거해 인덱스 구조를 슬림화 하면 저장 효율이나 스캔 효율엔 좋겠지만 인덱스 분할이 자주 발생해 DML 성능이 나빠질 수 있기 때문이다. 인덱스 분할에 의한 경합을 줄일 목적으로, 초기부터 빈 공간을 남기도록 옵션을 주고 인덱스를 재생성할 수도 있다. 하지만 그 효ㅕ과는 일시적이다. 언젠가 빈 공간이 다시 채워지기 때문이며, 결국 적당한 시점마다 재생성 작업을 반복하지 않는 한 근본적인 해결책이 되지는 못한다. 인덱스 재생성하는 데 걸리는 시간과 부하도 무시할 수 없다. 따라서 인덱스의 주기적인 재생성 작업은 아래와 같이 예상효과가 확실할 때만 시행하는 것이 바람직하다.
            - 인덱스 분할에 의한 경합이 현저히 높을 때
            - 자주 사용되는 인덱스 스캔 효울을 높이고자 할 때, 특히 NL Join에서 반복 엑세스 되는 인덱스 높이가 증가했을 때
            - 대량의 Delete  w작업을 수행한 이후 다시 레코드가 입력되기까지 오랜 기간이 소요될 때
            - 총 레코드 수가 일정한데도 인덱스가 계속 커질때

  - 비트맵 인덱스
    - Oracle은 비트맵 인덱스 구조를 제공하며, 이 인덱스는 여러 인덱스를 동시에 활용할 수 있다는 장점 때문에 다양한 조건절이 사용되는, 특히 정형화되지 않는 임의 질의(ad-hoc query)가 많은 환경에 적합하다. 다만, 비트맵 인덱스는 Lock에 의한 DML 부하가 심한것이 단점이다. 레코드 하나만 변경되더라도 해당 비트맵 범위에 속한 모든 레코드에 Lock이 걸린다. OLTP성 환경에 비트맵 인덱스를 쓸 수 없는 이유가 여기에 있다.
  - 함수기반 인덱스
    - Oracle이 제공하는 함수기반 인덱스(Function Based Index, FBI)는 칼럼 값 자체가 아닌, 특정 함수를 적용한 값으로 BTree 인덱스를 만든다.
    <pre><code>select * from 주문 where nvl(주문수량, 0) < 100</code></pre>
    위 쿼리를 예로 들면 주문 수량 칼럼에 인덱스가 있어도 위처럼 인덱스 칼럼을 가공하면 정상적인 인덱스 사용이 불가능하다. 하지만 조건절과 똑같이 NVL 함수를 씌워 아래처럼 인덱스를 만들면 인덱스 사용이 가능하다. 주문수량이 NULL인 레코드는 인덱스에 0으로 저장된다.
    <pre><code>create index emp_x01 on emp( nvl(주문수량, 0) );</code></pre>
    주의할 점은 함수기반 인덱스는 데이터 입력, 수정 시 함수를 적용해야 하기 때문에 다소 부하가 있을 수 있으며, 사용된 함수가 사용자 정의 함수일 때는 부하가 더 심하다. 따라서 남용하지 말고 꼭 필요한 때만 사용해야한다.
  - 리버스 키 인덱스
    - 일련번호나 주문일시 같은 칼럼에 인덱스를 만들면, 입력되는 값이 순차적으로 증가하기 때문에 가장 오른쪽 리프 블록에만 데이터가 쌇인다. 이런 현상이 발생하는 인덱스를 흔히 'Right Crowing(또는 Right Habd) 인덱스' 라고 부르며, 동시 Insert 가 심할 때 인덱스 블록 경합을 일으켜 초당 트랙잭션 처리량을 크게 감소시킨다. 그럴 때 리버스 키 인덱스가 유용할 수 있는데, 이것은 말 그대로 입력된 키 값을 거꾸로 변환해서 저장하는 인덱스다. 조금 전에 설명한 함수기반 인덱스를 상기하면서, 아래와 같이 Reverse함수 에서 반환된 값을 저장하는 인덱스라고 생각하면 쉽다.
    <pre><code>create index order_inx01 on order(reverse(reg_date));</code></pre>순차적으로 입력되는 값을 거꾸로 변환해서 저장하면 데이터가 고르게 분포된다. 따라서 리프 블록 맨 우측에만 집중되는 트랜잭션을 리프 블록 전체에 고르게 분산시키는 효과를 얻을 수 있다. 하지만, 리버스 키 인덱스는 데이터를 거꾸로 입력하기 때문에 '=' 조건으로만 검색이 가능하다.
  - 클러스터 인덱스
    - Oracle에는 클러스터 테이블(Clustered Table)이라는 오브첵트가 있다. 클러스터 테이블에는 인덱스 클러스터와 해시 클러스터 두 가지가 있는데, 지금 설명하는 클러스터 인덱스는 인덱스 클러스터와 관련이 있다. 인덱스 클러스터 테이블은 클러스터 키 값이 같은 레코드가 한 블록에 모이도록 저장하는 구조를 사용한다. 한 블록에 모두 담을 수 없을 때는 새로운 블록을 할당해 클러스터 체인으로 연결한다.
    ![마크다운 로고](https://raw.github.com/dcurtis/markdown-mark/master/png/208x128.png)
