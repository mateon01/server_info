SQL 최적화 기본 원리
---
1. 옵티마이저
 옵티마이저는 사용자가 질의한 SQL문에 대해 최적의 실행 방법을 결정하는 역할을 수행한다. 이러한 최적의 실행 방법을 실행계획 이라고 한다. 이러한 옵티마이저는 최적의 실행 방법을 결정하는 방식에 따라 규칙기반 옵티마이저(RBO, Rule Based Optimizer)와 비용 기반 옵티마이저(CBO, Cost Based Optimizer)로 구분할 수 있다.
  - 규칙기반의 옵티마이저
    - 규칙(우선순위)을 가지고 실행계획을 생성한다. 실행게획을 생성하는 규칙을 이해하면 누구나 실행계획을 비교적 쉽게 예측 할 수 있다. SQL문을 싱행하기 위해 인덱스 유무와 종류, SQL문 에서 사용하는 연산자의 종류 그리고 SQL 문에서 참조하는 객체의 종류가 있다. 이러한 정보에 따라 우선 순위가 정해져 있고, 이 우선순위를 기반으로 실행 계획을 생성한다.
  - 비용기반의 옵티마이저
    - 비용기반 옵티마이저는 SQL문을 처리하는데 필요한 비용이 가장 적은 실행계왹을 선택하는 방식이다. 여기서 비용이란 SQL문을 처리하기 위해 예상되는 소요시간 또는 자원 사용량을 의미한다. 비용기반 옵티마이저는 비용을 예측하기 위해서 규칙기반 옵티마이저가 사용하지 않는 테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보와 시스템 통계정보 등을 이용한다.

2. 인덱스 테이블
  인덱스는 원하는 데이터를 쉽게 찾을 수 있도록 돕는 책의 찾아보기와 유사한 개념이다. 인덱스는 테이블을 기반으로 선택적으로 생성할 수 있는 구조이다. 테이블에 인덱스를 생성하지 않아도 되고 여러개를 생성해도 된다. 인덱스의 기본적인 목적은 검색 성능의 최적화이다. 즉, 검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다. 하지만, Insert, Update, Delete 등과 같은 DML 작업은 테이블과 인덱스를 함께 변경해야 하기 때문에 오히려 느려질 수 있다는 단점이 있다.
    - 전체 테이블 스캔
      1. SQL문에 조건지 존재하지 않는 경우
      2. SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우
      3. 옵티마이저의 취사 선택
      4. 그 밖의 경우
        - 병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.
    - 인덱스 테이블 스캔
      1. 인덱스 유일 스캔
      2. 인덱스 범위 스캔
      3. 인덱스 역순 범위 스캔

3. 인덱스 스캔 방식
  - Index Range Scan
    - Index Range Scan은 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위(Range)만 스캔하는 방식이다. B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있다.
  - Index Full Scan
    - Index Full Scan은 수직적 탐색없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐생하는 방식으로서. 대개는 데이터 검색을 위한 최적의 인덱스가 없을때 차선으로 선택된다.
      * Index Full Scan의 효용성
        - 선두 칼럼이 조건절에 없으면 옵티마이저는 우선적으로 Table Full Scan을 고려한다. 그런데 대용량 테이블이어서 Table Full Scan의 부탐이 크다면 옵티마엊는 인덱스를 활요하는 방법을 다시 생각해 보지 않을 수 없다. 데이터 저장공간은 '가로*세로' 즉, '칼럼길이*레코드 수'에 의해 결정되므로 대개 인덱스가 차지하는 면적은 테이블보다 훨씬 적게 마련이다. 만약 인덱스 스캔 단계에서 대부분 레코드를 필터링 하고 일부에 대해서만 테이블 액세스가 발생하는 경우라면 테이블 전체를 스캔하는 것 보다 탓다. 이럴때 옵티마이저는 Index Full Scan 방식을 선택 할 수 있다.
      * 인덱스를 이용한 소트 연산 대체
        - Index Full Scan은 Index Range Scan과 마찬가지로 그 결과집합이 인덱스 칼럼 순으로 정렬 되므로 Sort Order By 연산을 생략할 목적으로 사용 될 수 있는데, 이는 차선책으로 선택됐다기보다 옵티마이저가 전략적으로 선택한 경우에 해당한다.
  - Index Unique Scan
    - Index Unique Scan은 수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.
  - Index Skip Scan
    - 인덱스 선두 칼럼이 조건절로 사용되지 않으면 옵티아미저는 기본적으로 Table Full Scan을 선택한다. 또는, Table Full Scan 보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면 Index Full Scan 방식을 사용한다고 했다. Oracle은 인덱스 선두 칼럼이 조건절에 빠졌어도 인덱스를 활용하는 새로운 스캔방식을 9i 버전부터 선보였는데, 바로 index Skip Scan이 그것이다.

    Index Skip Scan 내부 수행 원리를 간단히 요약하면, 루트 또는 브랜치 블록에서 읽은 칼럼값 정보를 이용해 조건에 부합하는 레코드를 포함할 가능성 있는 하위 블록만 골라서 액세스 하는 방식이라고 할 수 있다.

  - Index Fast Full Scan
    - 말 그대로 Index Fast Full Scan은 Index Full Scan보다 빠르다. Index Fast Full Scan이 Index Full Scan보다 빠른 이유는, 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Mulitiblock Read 방식으로 스캔하기 때문이다.

|Index Full Scan|Index Fast Full Scan|
|:-----------|:-------------------|
|1. 인덱스 구조를 따라 스캔|1. 세그먼트 전체를 스캔|
|2. 결과집합 순서 보장|2. 결과집합 순서 보장 안됨|
|3. Single Block I/O|2. MultiBlock I.O|
|4. 병렬스캔 불가(파티션 돼 있지 않다면)   |4. 병렬스캔 가능   |
|5. 인덱스에 포함되지 않은 칼럼 조회 시에도 사용 가능   |5. 인덱스에 포함된 칼럼으로만 조회 할 때 사용 가능   |
